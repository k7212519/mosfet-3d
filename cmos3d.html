<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMOS 3D 结构展示 - Planar, SOI, FinFET, GAAFET</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(255, 255, 255, 0.05); /* Slightly more transparent */
            padding: 10px 20px; /* Reduced padding */
            border-radius: 20px; /* Refined radius */
            backdrop-filter: blur(20px) saturate(180%); /* Stronger blur and saturation */
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15); /* Thinner/lighter border */
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3); /* Softer shadow */
            z-index: 100;
            width: auto;
            max-width: 90vw;
            box-sizing: border-box;
            overflow-x: auto; /* Allow scroll on very narrow screens if needed, or wrap */
            flex-wrap: nowrap;
            scrollbar-width: none; /* Hide scrollbar Firefox */
        }
        #ui-container::-webkit-scrollbar { 
            display: none;  /* Hide scrollbar Chrome/Safari */
        }
        .btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
            padding: 8px 16px; /* Smaller padding */
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 13px; /* Smaller font */
            font-weight: 500;
            letter-spacing: 0.5px;
            white-space: nowrap; /* Prevent text wrap */
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .btn.active {
            background: rgba(255, 255, 255, 0.95);
            color: #000;
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            font-weight: 600;
        }
        #logo {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 100px;
            height: auto;
            z-index: 10;
            transition: width 0.3s ease;
        }
        #info-panel {
            position: absolute;
            top: 30px;
            right: 30px;
            text-align: right;
            color: white;
            max-width: 350px;
            pointer-events: none;
            transition: all 0.3s ease;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5); /* Better readability */
        }
        h1 { margin: 0 0 8px 0; font-size: 24px; font-weight: 300; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 14px; line-height: 1.6; color: rgba(255, 255, 255, 0.8); margin: 0; }
        .highlight { color: #4db8ff; font-weight: bold; }

        /* Mobile Optimization */
        @media (max-width: 768px) {
            #ui-container {
                bottom: 20px;
                padding: 8px 15px;
                gap: 8px;
                width: 90%;
                justify-content: center;
                flex-wrap: wrap; /* Wrap buttons on 2 rows if needed */
            }
            .btn {
                padding: 6px 12px;
                font-size: 11px; /* Even smaller font */
                border-radius: 12px;
                flex: 1 0 auto; /* Allow growing to fill space */
                text-align: center;
            }
            #logo {
                top: 20px;
                left: 20px;
                width: 70px; /* Smaller logo */
            }
            #info-panel {
                top: 20px;
                right: 20px;
                max-width: 200px; /* Constraint width */
            }
            h1 {
                font-size: 16px; /* Smaller title */
                margin-bottom: 5px;
            }
            p {
                font-size: 11px; /* Smaller description */
                line-height: 1.4;
            }
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <img id="logo" src="assets/logo_cycore.png" alt="Logo">

    <div id="info-panel">
        <h1 id="model-title">CMOS 展示</h1>
        <p id="model-desc">选择下方按钮查看不同工艺节点下的晶体管结构。</p>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <button class="btn active" onclick="switchModel('planar')">Planar CMOS</button>
        <button class="btn" onclick="switchModel('soi')">SOI CMOS</button>
        <button class="btn" onclick="switchModel('finfet')">FinFET</button>
        <button class="btn" onclick="switchModel('gaafet')">GAAFET</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // State
        let scene, camera, renderer, controls;
        let currentModelGroup = null;
        let animationId;
        
        // Particle System for Electron Flow
        const particleSystem = {
            mesh: null,
            count: 200, // Reduced from 400
            dummy: new THREE.Object3D(),
            data: [], // { velocity, boundary }
            init: function(type) {
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                    this.mesh = null;
                    this.data = [];
                }

                const geometry = new THREE.SphereGeometry(0.03, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.mesh = new THREE.InstancedMesh(geometry, material, this.count);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                
                // Initialize based on type
                for (let i = 0; i < this.count; i++) {
                    this.resetParticle(i, type, true);
                }
                
                if (currentModelGroup) {
                    currentModelGroup.add(this.mesh); // Attach to rotating model
                } else {
                    scene.add(this.mesh);
                }
            },
            resetParticle: function(i, type, randomX = false) {
                const dummy = this.dummy;
                
                // Common X range (Source to Drain)
                // Models typically span X: -2 to 2 or -2.5 to 2.5
                // Flow usually from Source (Left/Negative) to Drain (Right/Positive)
                let xStart = -2.3; // Adjusted to match aligned geometry (4.6 width)
                let xEnd = 2.3;
                let x = randomX ? (Math.random() * (xEnd - xStart) + xStart) : xStart;
                let y, z;
                let speed = 0.01 + Math.random() * 0.01; // Slower speed (was 0.05)

                // Specific Geometry Logic
                if (type === 'planar' || type === 'soi') {
                    // Planar/SOI: Flow on surface of active area
                    // Active Width Z: 2 (-1 to 1)
                    // Active Top Y: 
                    // Planar: 0.1 + EPS + 0.1 (half height) = ~0.2 (Oxide is at 0.225) -> Flow at y=0.2
                    // SOI: Active center -0.15 + EPS*2. Height 0.2. Top ~ -0.05.
                    
                    z = (Math.random() - 0.5) * 1.8; // Margin inside Z width 2
                    
                    if (type === 'planar') y = 0.21; // Just under oxide
                    if (type === 'soi') y = -0.04; // Just under oxide
                    
                } else if (type === 'finfet') {
                    // FinFET: Flow on Top and Sides of Fins
                    // Fin Centers Z: -0.6 and 0.6
                    // Fin Dims: Width 0.3, Height 0.8
                    // Fin Y Center: 0.15 + EPS. Top Y: 0.15 + 0.4 = 0.55.
                    // Side Z range: Center +/- 0.15.
                    
                    const finChoice = Math.random() > 0.5 ? 0.6 : -0.6; // Choose Fin 1 or 2
                    const faceChoice = Math.random(); // Top or Sides?
                    
                    if (faceChoice > 0.6) { // Top (40% chance)
                        y = 0.56; // Just above fin
                        z = finChoice + (Math.random() - 0.5) * 0.25;
                    } else { // Sides (60% chance)
                        // Side Y range: Center 0.15. Height 0.8 -> -0.25 to 0.55.
                        // We want mostly channel region under gate? Or whole fin? Whole fin for now.
                        y = 0.15 + (Math.random() - 0.5) * 0.7; 
                        const sideOffset = 0.16; // Just outside width 0.3/2 = 0.15
                        z = finChoice + (Math.random() > 0.5 ? sideOffset : -sideOffset);
                    }

                } else if (type === 'gaafet') {
                    // GAAFET: Flow on SURFACE of the nanosheets for better visibility
                    // 3 Sheets at Y: -1.0, -0.4, 0.2 (approx with i*0.6)
                    
                    const sheetIdx = Math.floor(Math.random() * 3);
                    // i=0: -1.0 + EPS. i=1: -0.4 + EPS. i=2: 0.2 + EPS.
                    const sheetY = -1.0 + (sheetIdx * 0.6) + 0.002;
                    
                    // Distribute on the outer skin of the nanosheet
                    // Sheet Dims: Width (Z) 1.0, Height (Y) 0.15
                    const face = Math.random();
                    const hH = 0.075; // Half Height
                    const hW = 0.5;   // Half Width
                    const eps = 0.02; // Offset
                    
                    if (face < 0.33) { // Top Surface
                        y = sheetY + hH + eps;
                        z = (Math.random() - 0.5) * (hW * 2);
                    } else if (face < 0.66) { // Bottom Surface
                        y = sheetY - hH - eps;
                        z = (Math.random() - 0.5) * (hW * 2);
                    } else if (face < 0.83) { // Front Side
                        y = sheetY + (Math.random() - 0.5) * (hH * 2);
                        z = hW + eps;
                    } else { // Back Side
                        y = sheetY + (Math.random() - 0.5) * (hH * 2);
                        z = -hW - eps;
                    }
                    
                    // Constrain X for GAAFET (S/D are at +/- 1.8)
                    xStart = -2.2;
                    xEnd = 2.2;
                    if (!randomX) x = xStart;
                }

                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                
                // Store state
                this.data[i] = {
                    velocity: speed,
                    boundary: xEnd,
                    start: xStart,
                    type: type,
                    y: y,
                    z: z
                };
                
                this.mesh.setMatrixAt(i, dummy.matrix);
            },
            update: function() {
                if (!this.mesh) return;
                
                const dummy = this.dummy;
                
                for (let i = 0; i < this.count; i++) {
                    const d = this.data[i];
                    // Retrieve current position
                    this.mesh.getMatrixAt(i, dummy.matrix);
                    dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                    
                    // Move
                    dummy.position.x += d.velocity;
                    
                    // Reset if out of bounds
                    if (dummy.position.x > d.boundary) {
                        this.resetParticle(i, d.type, false); // Reset to start
                        // Re-fetch new position/matrix from reset
                        // But wait, resetParticle writes to mesh.setMatrixAt(i)...
                        // So we don't need to do anything else for this particle in this frame
                        // effectively. 
                        // However, resetParticle sets it to start.
                    } else {
                         // Update matrix
                        dummy.updateMatrix();
                        this.mesh.setMatrixAt(i, dummy.matrix);
                    }
                }
                this.mesh.instanceMatrix.needsUpdate = true;
            }
        };

        // Materials - High Quality PBR
        // 统一材质属性，仅颜色区分
        const baseSiliconProps = {
            metalness: 0.6,
            roughness: 0.1, // More glossy
            clearcoat: 0.5, // Enhanced gloss
            clearcoatRoughness: 0.1
        };

        const materials = {
            silicon: new THREE.MeshPhysicalMaterial({
                color: 0x333344,
                ...baseSiliconProps
            }),
            siliconActive: new THREE.MeshPhysicalMaterial({ // Doped regions (Source/Drain)
                color: 0xaa4444, 
                ...baseSiliconProps
            }),
            substrate: new THREE.MeshPhysicalMaterial({ // Substrate using same material quality as silicon
                color: 0x555555, // Brightened from 0x222222
                ...baseSiliconProps
            }),
            oxide: new THREE.MeshPhysicalMaterial({ // SiO2 / High-k
                color: 0xaaccff,
                transparent: true,
                opacity: 0.4,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.6,
                thickness: 0.5
            }),
            gateMetal: new THREE.MeshPhysicalMaterial({ // Poly-Si or Metal Gate
                color: 0xffd700, // Goldish look
                metalness: 0.9,
                roughness: 0.15,
                clearcoat: 0.3
            }),
            spacer: new THREE.MeshPhysicalMaterial({
                color: 0x888888,
                metalness: 0.1,
                roughness: 0.5
            })
        };

        // Init function
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 4, 8); // Lowered Y slightly (was 5) to look more directly at center

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 20;
            // Adjusted target Y to 0 (was 1) to center the model better vertically
            controls.target.set(0, 0, 0);

            // Lights
            setupLights();

            // Initial Model based on URL param
            const urlParams = new URLSearchParams(window.location.search);
            const modelIndex = urlParams.get('type'); // expecting ?type=1, 2, 3, or 4
            
            if (modelIndex === '2') {
                createSOICMOS();
            } else if (modelIndex === '3') {
                createFinFET();
            } else if (modelIndex === '4') {
                createGAAFET();
            } else {
                createPlanarCMOS(); // Default to 1
            }

            // Resize listener
            window.addEventListener('resize', onWindowResize);

            // Animation Loop
            animate();
        }

        function setupLights() {
            RectAreaLightUniformsLib.init();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Increased ambient (was 0.4)
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 40); // Increased intensity (was 30)
            spotLight.position.set(5, 10, 5);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            spotLight.shadow.bias = -0.0001;
            spotLight.shadow.mapSize.width = 1024; // Reduced shadow map size for performance
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);

            const rectLight1 = new THREE.RectAreaLight(0x4488ff, 12, 10, 10); // Increased intensity (was 8)
            rectLight1.position.set(-5, 5, 5);
            rectLight1.lookAt(0, 0, 0);
            scene.add(rectLight1);

            const rectLight2 = new THREE.RectAreaLight(0xff8844, 12, 10, 10); // Increased intensity (was 8)
            rectLight2.position.set(5, 5, -5);
            rectLight2.lookAt(0, 0, 0);
            scene.add(rectLight2);

            // Bottom Light - Fill for the underside
            const bottomLight = new THREE.DirectionalLight(0xaabbff, 3); // Increased intensity (was 2)
            bottomLight.position.set(0, -5, 0);
            bottomLight.target.position.set(0, 0, 0);
            scene.add(bottomLight);
            scene.add(bottomLight.target);
        }

        function clearScene() {
            if (currentModelGroup) {
                scene.remove(currentModelGroup);
                currentModelGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        // Materials are reused, so don't dispose them
                    }
                });
                currentModelGroup = null;
            }
            // Force garbage collection hint
            renderer.renderLists.dispose();
        }

        // --- Model Generation Functions ---

        // 1. Planar CMOS (Ordinary)
        window.createPlanarCMOS = function() {
            clearScene();
            updateUI('planar');
            const group = new THREE.Group();
            const EPS = 0.002; // Small offset to prevent Z-fighting

            // Substrate (Size reduced)
            const substrateGeo = new RoundedBoxGeometry(4.5, 1, 3, 4, 0.1);
            const substrate = new THREE.Mesh(substrateGeo, materials.substrate);
            substrate.position.y = -0.5;
            substrate.receiveShadow = true;
            group.add(substrate);

            // Active Silicon (Source/Drain) - Lifted slightly
            // Widened to 4.5 to align with substrate edges
            const activeGeo = new RoundedBoxGeometry(4.5, 0.2, 2, 4, 0.02);
            const active = new THREE.Mesh(activeGeo, materials.siliconActive);
            active.position.y = 0.1 + EPS; 
            active.castShadow = true;
            active.receiveShadow = true;
            group.add(active);
            
            // Channel - Lifted slightly more and scaled to avoid overlapping faces with Active
            const channelGeo = new RoundedBoxGeometry(1, 0.2, 2, 4, 0.02);
            const channel = new THREE.Mesh(channelGeo, materials.silicon); 
            channel.position.y = 0.1 + EPS * 2;
            channel.scale.set(1.02, 1.02, 1.02); // Make it slightly larger to cover the seam
            group.add(channel);

            // Gate Oxide - Lifted
            const oxideGeo = new RoundedBoxGeometry(1, 0.05, 2, 4, 0.01); // Smaller radius for thin layer
            const oxide = new THREE.Mesh(oxideGeo, materials.oxide);
            oxide.position.y = 0.225 + EPS * 3;
            group.add(oxide);

            // Gate - Lifted
            const gateGeo = new RoundedBoxGeometry(1, 1, 2, 4, 0.05);
            const gate = new THREE.Mesh(gateGeo, materials.gateMetal);
            gate.position.y = 0.75 + EPS * 4;
            gate.castShadow = true;
            gate.receiveShadow = true;
            group.add(gate);
            
            scene.add(group);
            currentModelGroup = group;
            particleSystem.init('planar');
        };

        // 2. SOI CMOS (Silicon On Insulator)
        // Fix: Increase BOX thickness and adjust positions to avoid Z-fighting
        window.createSOICMOS = function() {
            clearScene();
            updateUI('soi');
            const group = new THREE.Group();
            const EPS = 0.002;

            // Substrate (Base)
            // Height 0.5, Center -1.0 -> Top at -0.75
            const substrateGeo = new RoundedBoxGeometry(4.5, 0.5, 3, 4, 0.1);
            const substrate = new THREE.Mesh(substrateGeo, materials.substrate);
            substrate.position.y = -1.0;
            substrate.receiveShadow = true;
            group.add(substrate);

            // BOX (Buried Oxide) - Lifted
            const boxGeo = new RoundedBoxGeometry(4.5, 0.5, 3, 4, 0.05);
            const box = new THREE.Mesh(boxGeo, materials.oxide);
            box.position.y = -0.5 + EPS;
            box.receiveShadow = true;
            group.add(box);

            // Active Silicon (Thin body) - Lifted
            // Widened to 4.5 to align with substrate/BOX edges
            const activeGeo = new RoundedBoxGeometry(4.5, 0.2, 2, 4, 0.02);
            const active = new THREE.Mesh(activeGeo, materials.siliconActive);
            active.position.y = -0.15 + EPS * 2;
            active.castShadow = true;
            group.add(active);

             // Channel - Lifted and Scaled
            const channelGeo = new RoundedBoxGeometry(1, 0.2, 2, 4, 0.02);
            const channel = new THREE.Mesh(channelGeo, materials.silicon);
            channel.position.y = -0.15 + EPS * 3;
            channel.scale.set(1.02, 1.02, 1.02);
            group.add(channel);

            // Gate Oxide - Lifted
            const oxideGeo = new RoundedBoxGeometry(1, 0.05, 2, 4, 0.01);
            const oxide = new THREE.Mesh(oxideGeo, materials.oxide);
            oxide.position.y = -0.025 + EPS * 4;
            group.add(oxide);

            // Gate - Lifted
            const gateGeo = new RoundedBoxGeometry(1, 1, 2, 4, 0.05);
            const gate = new THREE.Mesh(gateGeo, materials.gateMetal);
            gate.position.y = 0.5 + EPS * 5;
            gate.castShadow = true;
            group.add(gate);

            scene.add(group);
            currentModelGroup = group;
            particleSystem.init('soi');
        };

        // 3. FinFET
        window.createFinFET = function() {
            clearScene();
            updateUI('finfet');
            const group = new THREE.Group();
            const EPS = 0.002;

            // Substrate - Made slightly wider and deeper to contain STI without Z-fighting on sides
            const substrateGeo = new RoundedBoxGeometry(4.6, 0.5, 3.1, 4, 0.1);
            const substrate = new THREE.Mesh(substrateGeo, materials.substrate);
            substrate.position.y = -0.5;
            substrate.receiveShadow = true;
            group.add(substrate);

            // Fins (Multiple)
            // Length set to 4.6 to align with substrate edges
            const finGeo = new RoundedBoxGeometry(4.6, 0.8, 0.3, 4, 0.03); // Tall and thin, small radius
            
            // Fin 1
            const fin1 = new THREE.Mesh(finGeo, materials.siliconActive);
            fin1.position.set(0, 0.15 + EPS, -0.6); 
            fin1.castShadow = true;
            group.add(fin1);

            // Fin 2
            const fin2 = new THREE.Mesh(finGeo, materials.siliconActive);
            fin2.position.set(0, 0.15 + EPS, 0.6);
            fin2.castShadow = true;
            group.add(fin2);

            // Oxide (Isolation between fins - STI)
            // Sits ON TOP of substrate. Substrate Top = -0.25.
            // STI Height = 0.4. Center = -0.25 + 0.2 = -0.05.
            // Width/Depth = 4.5/3.0 (Smaller than substrate 4.6/3.1 to avoid side flicker)
            const stiGeo = new RoundedBoxGeometry(4.5, 0.4, 3.0, 4, 0.04);
            const sti = new THREE.Mesh(stiGeo, new THREE.MeshPhysicalMaterial({
                color: 0xcccccc, // Lighter grey for better visibility
                roughness: 0.5,
                metalness: 0.1
            })); 
            sti.position.y = -0.05 + EPS; 
            sti.receiveShadow = true;
            group.add(sti);

            // Gate - Wraps around fins
            const gateWidth = 1.25; 
            const gateHeight = 1.25; 
            const gateDepth = 3.2; // Slightly wider than substrate to look like a proper line

            const gateGeo = new RoundedBoxGeometry(gateWidth, gateHeight, gateDepth, 4, 0.05);
            const gate = new THREE.Mesh(gateGeo, materials.gateMetal);
            gate.position.set(0, 0.5, 0);
            gate.material = materials.gateMetal.clone();
            gate.material.transparent = true;
            gate.material.opacity = 0.7; // Added transparency
            gate.castShadow = true;
            group.add(gate);

            scene.add(group);
            currentModelGroup = group;
            particleSystem.init('finfet');
        };

        // 4. GAAFET (Gate-All-Around / Nanosheet)
        window.createGAAFET = function() {
            clearScene();
            updateUI('gaafet');
            const group = new THREE.Group();
            const EPS = 0.002;

            // Substrate
            const substrateGeo = new RoundedBoxGeometry(4.5, 0.5, 3, 4, 0.1);
            const substrate = new THREE.Mesh(substrateGeo, materials.substrate);
            substrate.position.y = -1.5;
            substrate.receiveShadow = true;
            group.add(substrate);

            // Source and Drain Pillars
            // Reduced thickness (0.6) and adjusted position to fit within substrate (width 4.5)
            const sdGeo = new RoundedBoxGeometry(0.6, 2, 2, 4, 0.05);
            const source = new THREE.Mesh(sdGeo, materials.siliconActive);
            source.position.set(-1.8, -0.5 + EPS, 0);
            source.castShadow = true;
            group.add(source);

            const drain = new THREE.Mesh(sdGeo, materials.siliconActive);
            drain.position.set(1.8, -0.5 + EPS, 0);
            drain.castShadow = true;
            group.add(drain);

            // Nanosheets
            // Length reduced to 3.6 to match new S/D positions
            const sheetGeo = new RoundedBoxGeometry(3.6, 0.15, 1, 4, 0.015);
            
            for(let i = 0; i < 3; i++) {
                const sheet = new THREE.Mesh(sheetGeo, materials.silicon);
                sheet.position.set(0, -1.0 + (i * 0.6) + EPS, 0); 
                sheet.castShadow = true;
                group.add(sheet);
            }

            // Gate - Made slightly larger and offset
            // Narrowed width (X-axis) from 1.55 to 1.0 to look more like a gate stack
            const gateGeo = new RoundedBoxGeometry(1.0, 2.25, 2.55, 4, 0.05); 
            const gate = new THREE.Mesh(gateGeo, materials.gateMetal);
            gate.position.set(0, -0.4, 0);
            gate.material = materials.gateMetal.clone();
            gate.material.transparent = true; // Make transparent to see particles inside
            gate.material.opacity = 0.7;      // Increased opacity from 0.5 to 0.7
            gate.castShadow = true;
            group.add(gate);

            scene.add(group);
            currentModelGroup = group;
            particleSystem.init('gaafet');
        };

        // Helper for UI
        function updateUI(type) {
            const titleMap = {
                'planar': 'Planar CMOS (平面晶体管)',
                'soi': 'SOI CMOS (绝缘体上硅)',
                'finfet': 'FinFET (鳍式场效应晶体管)',
                'gaafet': 'GAAFET (全环绕栅极)'
            };
            const descMap = {
                'planar': '传统的平面结构，电流在硅片表面的二维平面中流动。随着尺寸缩小，漏电流难以控制。',
                'soi': '在硅衬底和活性层之间增加了一层氧化埋层(BOX)，减少寄生电容和漏电流，适合低功耗应用。',
                'finfet': '将通道竖立起来形成“鳍(Fin)”，栅极三面包裹通道，极大增强了对电流的控制能力，是22nm-5nm节点的主流技术。',
                'gaafet': '栅极四面完全包裹通道（通常为纳米线或纳米片），提供极致的电流控制能力，是3nm及以下节点的关键技术。'
            };

            document.getElementById('model-title').innerText = titleMap[type];
            document.getElementById('model-desc').innerText = descMap[type];

            document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
        }

        window.switchModel = function(type) {
             const buttons = document.querySelectorAll('.btn');
             buttons.forEach(b => {
                 if(b.getAttribute('onclick').includes(type)) {
                     b.classList.add('active');
                 } else {
                     b.classList.remove('active');
                 }
             });

             if(type === 'planar') createPlanarCMOS();
             if(type === 'soi') createSOICMOS();
             if(type === 'finfet') createFinFET();
             if(type === 'gaafet') createGAAFET();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            controls.update();
            
            if(currentModelGroup) {
                currentModelGroup.rotation.y += 0.002;
            }
            
            particleSystem.update();

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>